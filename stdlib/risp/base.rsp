(import [risp internal primitives])
(export def let fn if quote export ... _ defmacro macro-rules : type-predicate)

(import [risp internal types])
(export Any Bool String Symbol Int Float Char List Listof Vector Vectorof Setof Map U Type?
        -> ->!)

(export defn)
(defmacro defn (macro-rules #{} [
  [(defn destruc fn-data ...) (def destruc (fn fn-data ...))]
]))

; `do` becomes a self-executing function containing the inner statements
(export do)
(defmacro do (macro-rules #{} [
  [(do expr-data ...) ((fn () expr-data ... ))]
]))

; emulates `apply` from R7RS and Clojure
(export apply)
(defmacro apply (macro-rules #{} [
 [(apply fun fixed ... rest) (fun fixed ... rest (... ...))]
]))

(export list)
(defn list #{A} ([l : A] ...) -> (Listof A)
  l)

(export when)
(defmacro when (macro-rules #{} [
  [(when test body-data ...) (if test (do body-data ...) false)]
]))

(export and)
(defmacro and (macro-rules #{} [
  [(and) true]
  [(and test) test]
  [(and test1 test2 ...)
   (if test1 (and test2 ...) false)]
]))

(export or)
(defmacro or (macro-rules #{} [
  [(or) false]
  [(or test) test]
  [(or test1 test2 ...)
   (if test1 true (or test2 ...))]
]))

(export not)
(defmacro not (macro-rules #{} [
  [(not test) (if test false true)]
]))
