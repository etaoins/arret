(import [arret internal primitives])
(export def let fn if quote export ... _ defmacro letmacro macro-rules : type-predicate
        deftype compile-error do)

(import [arret internal types])
(export Any Bool Str Sym Int Float Char List Listof Vector Vectorof Setof Map U Type?
        -> ->!)

(import [stdlib rust])
(export length panic = print! println! exit)

(export defn)
(defmacro defn (macro-rules
  [(destruc fn-data ...) (def destruc (fn fn-data ...))]
))

; emulates `apply` from R7RS and Clojure
(export apply)
(defmacro apply (macro-rules
  [(fun fixed ... rest) (fun fixed ... rest (... ...))]
))

(export list)
(defn list #{A} ([l : A] ...) -> (Listof A)
  l)

(export when)
(defmacro when (macro-rules
  [(test body-data ...) (if test (do body-data ...) ())]
))

(export when-not)
(defmacro when-not (macro-rules
  [(test body-data ...) (if test () (do body-data ...))]
))

(export and)
(defmacro and (macro-rules
  [() true]
  [(test) test]
  [(test1 test2 ...)
   (if test1 (and test2 ...) false)]
))

(export or)
(defmacro or (macro-rules
  [() false]
  [(test) test]
  [(test1 test2 ...)
   (if test1 true (or test2 ...))]
))

(export not)
(defmacro not (macro-rules
  [(test) (if test false true)]
 ))

(export ann)
(defmacro ann (macro-rules
 [(val Type) (let [[_ : Type] val] val)]
))

(export has-type?)
(defmacro has-type? (macro-rules
  [(val Type) ((type-predicate Type) val)]
))

(export first)
(defn first #{T} (([head : T] _ ...)) -> T
  head)

(export rest)
(defn rest #{T} ((_ [tail : T] ...)) -> (Listof T)
  tail)

; Type predicates
(defmacro deftypred (macro-rules
  [(name Type) (do
    (export name)
    (def name (type-predicate Type))
  )]
))

(deftypred sym? Sym)
(deftypred str? Str)
(deftypred bool? Bool)
(deftypred int? Int)
(deftypred float? Float)
(deftypred char? Char)
(deftypred list? (Listof Any))
(deftypred vector? (Vectorof Any))
(deftypred set? (Setof Any))
(deftypred map? (Map Any Any))
(deftypred fn? (... ->! Any))
(deftypred empty? ())
