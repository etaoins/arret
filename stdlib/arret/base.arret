(import [arret internal primitives])
(export def let fn if quote export ... _ defmacro letmacro macro-rules : deftype compile-error do
        =)

(import [arret internal types])
(export Any Bool Str Sym Int Float Char List Listof Vector Vectorof Setof Map U -> ->!
        str? sym? bool? int? float? char? list? vector? set? map? fn? nil?)

(import [stdlib rust])
(export length panic print! println! exit! cons map filter)

(export defn)
(defmacro defn (macro-rules
  [(destruc fn-data ...) (def destruc (fn fn-data ...))]
))

; emulates `apply` from R7RS and Clojure
(export apply)
(defmacro apply (macro-rules
  [(fun fixed ... rest) (fun fixed ... rest (... ...))]
))

(export list)
(defn list #{A} ([l : A] ...) -> (Listof A)
  l)

(export when)
(defmacro when (macro-rules
  [(test body-data ...) (if test (do body-data ...) ())]
))

(export when-not)
(defmacro when-not (macro-rules
  [(test body-data ...) (if test () (do body-data ...))]
))

(export and)
(defmacro and (macro-rules
  [() true]
  [(test) test]
  [(test1 test2 ...)
   (if test1 (and test2 ...) false)]
))

(export or)
(defmacro or (macro-rules
  [() false]
  [(test) test]
  [(test1 test2 ...)
   (if test1 true (or test2 ...))]
))

(export not)
(defmacro not (macro-rules
  [(test) (if test false true)]
 ))

(export ann)
(defmacro ann (macro-rules
 [(val Type) (let [[_ : Type] val] val)]
))

(export first)
(defn first #{T} (([head : T] _ ...)) -> T
  head)

(export rest)
(defn rest #{T} ((_ [tail : T] ...)) -> (Listof T)
  tail)
