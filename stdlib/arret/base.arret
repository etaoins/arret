(import [arret internal primitives])
(export def let fn if quote export defmacro letmacro macro-rules deftype compile-error do =)

(import [arret internal types])
(export Any Bool Str Sym Int Float Num Char List Vector Vectorof Setof Map U -> ->! str? sym?
        bool? num? int? float? char? list? vector? set? map? fn? nil?)

(import [stdlib rust])
(export length panic print! println! exit! cons map filter fold concat member? int float + * - /
        rem quot)

(export defn)
(defmacro defn (macro-rules
  [(destruc fn-data ...) (def destruc (fn fn-data ...))]
))

; emulates `apply` from R7RS and Clojure
(export apply)
(defmacro apply (macro-rules
  [(fun fixed ... rest) (fun fixed ... & rest)]
))

(export list)
(defn list #{A} (& [l A]) -> (List & A)
  l)

(export when)
(defmacro when (macro-rules
  [(test body-data ...) (if test (do body-data ...) ())]
))

(export when-not)
(defmacro when-not (macro-rules
  [(test body-data ...) (if test () (do body-data ...))]
))

(export and)
(defmacro and (macro-rules
  [() true]
  [(test) test]
  [(test1 test2 ...)
   (if test1 (and test2 ...) false)]
))

(export or)
(defmacro or (macro-rules
  [() false]
  [(test) test]
  [(test1 test2 ...)
   (if test1 true (or test2 ...))]
))

(export not)
(defmacro not (macro-rules
  [(test) (if test false true)]
 ))

(export ann)
(defmacro ann (macro-rules
 [(val Type) (let [[_ Type] val] val)]
))

(export first)
(defn first #{T} (([head T] & _)) -> T
  head)

(export rest)
(defn rest #{T} ((_ & [tail T])) -> (List & T)
  tail)

(export zero?)
(defn zero? ([n Num]) -> Bool
  (if (int? n)
    (= n 0)
    (= n 0.0)))

(export nan?)
(defn nan? ([f Float]) -> Bool
  (not (= f f)))

(export infinite?)
(defn infinite? ([f Float]) -> Bool
  (or (= f ##Inf) (= f ##-Inf)))

(export inc)
(defn inc ([i Int]) -> Int
  (+ i 1))

(export dec)
(defn dec ([i Int]) -> Int
  (- i 1))

(export ->>)
(defmacro ->> (macro-rules
  [(initial) initial]
  [(initial (first-fn args ...) rest ...)
    (->> (first-fn args ... initial) rest ...)]
))